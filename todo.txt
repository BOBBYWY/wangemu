============================================================================
Emulator TODO list
============================================================================

*) None of the recent changes has been compiled on OSX, so most likely there
   will be problems.  Once the code is somewhat stable under windows,
   build it on OSX and iron out the problems.

*) use smart pointers instead of raw pointers
    std::shared_ptr<>, std::make_shared<>, std::unique_ptr<>
        note: p464:
            shared_ptr<int> p1 = new int(1234); // syntax error
            shared_ptr<int> p2(new int(1234));  // OK
        and I think this would work too:
            shared_ptr<int> p3 = shared_ptr<int>(new int(1234));
        or better yet,
            shared_ptr<int> p3 = make_shared<int>(1234);  // I think

   basically, look for "delete" occurrences; if these were smart pointers,
   just setting the pointer to nullptr would automatically free the resource.
   eg, if the recent Scheduler m_timer[] vector held shared_ptr<Timer>
       it would also get rid of the zeroing out pointers of m_timer before
       calling resize.

*) improved 2236 terminal emulation

    - get rid of 1x1 dot matrix mode -- doesn't model the real hw,
      isn't readable
    - dot stream is gated by pixclk
    - alternate lines are always black, even in reverse video mode
    - the cursor should be two rows high (last two)
    - the cursor is always high-intensity if it is on a non-invering cell.
      on inverted cells it is just black.
    - the emulator inverts the entire charcell in inv mode, but the real
      terminal still has alternate lines solid black
    - box horizontal lines are stipped, not solid
    - the real 2336 has a 25th line, but only the upper box line attribute
      bits can be used.  this allows completing a box on the last row.

    - look at the schematics.
          are box overlay lines affected by blink/inv/bright attributes?
          is cursor             affected by blink/inv/bright attributes?
          is underline          affected by blink/inv/bright attributes?
      make the emulation match.

    - the Z80 doesn't necessarily store the stated value in the char cell.
      eg, when writing 0x8A, it actually saves 0x0A in the cell, to prevent
      an underline  (underline is active effectively only on 0x90-0xFF)
      but if the underline attribute is set, I believe the terminal will
      generate 0x8A with an underline.  double check the 

    - test some corner case on the real terminal.  eg, what happens if
      box line mode moves left or right off the screen?
      or up or down off the screen?
      or if there is an incorrect escape sequence: at what point are the
      bytes swallowed, or are they passed through?

    - looking at the 2236DW schematics (this one is legible):
        742-0903 2236DW INTEGRATED WORKSTATION 02-27-85_2
      the cursor is active on two scanlines, not one.
      underline is one scanline.
      an LS138 has tricky wiring:
            scanline  '138   2708 A[2:0]  cursor   underline  box L/R
            --------  -----  -----------  -------  ---------  -------
               0       Y0           ??0                       enabled
               1       Y1           ??1   
               2       Y2 n/c       ??0   
               3       Y3 n/c       ??1   
               4       none*        ??0   
               5       none*        ??1   
               6       none*        ??0   
               7       none*        ??1   
               8       Y4 n/c       ??0   
               9       Y5           ??1   enabled
              10       Y6           ??0   enabled  enabled
              11       Y7           ??1   
      In rows marked "*", row counter bit R2 goes to !G2A, which forces
      all outputs inactive.
      That it maps 12 rows makes me think this terminal uses a 12 scanline
      character cell, not 11.
      A[2:0] maps scanline row to one of eight charmap rows
      hmm, but a later 2236 schematic uses a PROM, and the truth table
      only shows entries for 0-A (11 scanline rows).  so I'm not sure why
      the one above uses Y7.

    - add smart terminal commands that I've skipped
        - make it so FB Cx actually causes a x/6 second delay
        - add command to return terminal ID
        - screen input (capture)

    - pre-blurring the char set to a glyph map, then blitting to the display
      works OK, except the cursor isn't blurred because it is dynamic, and
      edges of block graphic characters are noticable because the blurring
      kernel needs to span across characters.

      render unblurred and then use OGL to do the blurring.  this has the
      benefit of offering flexible scaling at low cost, and perhaps other
      video generation defect emulation.

    - if OGL isn't done, and if the mac port is still slow using the blit
      method so we have to keep the separate screen rendering path, try this.
      maybe the mac path shouldn't draw the cursor at all, and instead
      after the bitmap is converted to memDC, use the drawcursor/overlay
      routines to superimpose those features.  although blitting was very
      slow because we have to do thousands of blits requiring a lot of
      bitmap conversions, maybe drawing the overlays isn't so bad.

    - Fasstcom Terminal Specs v1.0.pdf, pdf page 8 says
      "... the terminal must always transmit a HEX(F8F9) every 3 to 5 seconds
       whenever it is ready to receive new data during idle time.
       This is called the constant poll."
      The emulated terminal doesn't.  Should it?

    - 742-0903.MNL.IntegratedTerminal2236DW.85-02-27.pdf, pdf page 68 says
          2236DW and 2236DW have mostly the same character generators,
          except for characters 5F/7F/80/8D/8F/DF/FF

    - the smart terminal menu should have an option to reset just the terminal

    - allow running terminal as a separate process
        - running in process is easier to manage for the casual user, though
        - actual serial port connection
        - running via sockets, allowing local or remote connection
        - perhaps as a javascript app, with multiple terminals as tabs?

*) add terminal mux emulation and terminal emulation so I can run MVP OS's

   - MXC,D,E notes: f:/jim/documents/wang2200/boards/terminal_mux_notes.txt

   - currently the division is
          IoCardKeyboard
        + IoCardDisplay
        + UiCrtKeyboard
        + UiCrtFrame
            + UiCrtStatusBar
            + UiCrtConfigDlg
            + UiCrt
                + UiCrt_Charset.h
                + UiCrtErrorDlg
     IoCardKeyboard.cpp has a fair amount of script processing logic in it,
        and I don't want to duplicate this for dumb & smart terminal modes
     UiCrtFrame constructor takes title, screen_size, io_addr.
        To reuse this, it needs a more generic attachment than io_addr;
        it needs to either me an io_addr port N of term mux at io_addr nn.
     Crt state is saved in the .ini file by ui/CRT-nn, where nn is the addr;
        this needs to be generalized
     The CrtFrame displays disk icons and activity, but in mux mode,
        there really shouldn't be a 1:1 mapping.  However, in the typical
        use case of one term, it is most useful.
     The CrtFrame logic enables some config options only on the "primary" crt,
        which historically has been the one at io_addr=05.  Rethink this.
     Config dialog needs to allow term mux configurations.
     UiCrt_Keyboard is really part of UiCrt, and provides the OnChar/OnKeyDown
        handling.  When it recognizes a key, it calls
            core_sysKeystroke(tied io_addr, key)
        which then routes it to the associated IoCardKeyboard function.
        The three related functions are
            core_sysKeystroke(io_addr, key)
            core_invokeScript(io_addr, filename)
            core_isKbInScriptMode(io_addr)  // used to disable some fcns while processing the script
        IoCardKeyboard::check_keyready() is a private function, and one of
            the things it does is poll the script.  To move this into the
            UiCrt logic would require IOCardKeyboard to move that script
            logic into UiCrt and have check_keyready() poll it there.
        Huh -- the logic grabs the next char from the script file only
            after the keystroke buffer is empty, but then waits 50ms before
            reporting it because something breaks in the ucode without it.
            (50ms of simulated time, not realtime)

    - emulating MXD, not MXE, because MXE runs only >= OS ver 2.4

    - emulate the MXD at the protocol level
        + more efficient
        + probably less less work overall
            - no 8080/z80 integration
            - no integrating the instruction dispatch & speed regulation
        - harder to offer an MXE option, which needs a real z80 emulation

    - allow term MUX to connect to a real serial port
        - a mac/linux/win lib: http://sigrok.org/wiki/Libserialport
        - http://wjwwood.io/serial/
        - https://iftools.com/opensource/ctb.en.php
        - windows+linux only: http://www.teuniz.net/RS-232/

    - section 8 of 2200MVP_MaintenanceManual.729-0584-A.1-84.pdf lists
      what is involved to upgrade a VP to an MVP.  part of it requires
      changing the boot ROM ucode to deal with the larger program memory.
      do I have these boot ROMs?
         double check boards/other boards/6789 and see if those ROMs match
         what the emulator uses
      the MVP service manual section 8.2 (page 8-2) says
          2200 VP/MVP Bootstrap Release 2.2 has been incorporated by ECN
          #9772.  For a system to operate with an expanded memory, this ECN
          must be performed.  The old PROMS on the 210-6789 must be replaced
          with the following:
              378-2045R1 = L27
              378-2046R1 = L28
              378-2047R1 = L29
      the 6789 board that I got the 2nd set of bootstrap PROMs from
      are windowed eproms without official Wang revision numbers.
      handwritten on the chips are the following:
          L29 says "2047"
          L28 says "2046R5"
          L27 says "2045R5"
      It is possible that the contents were R5, but the EPROMs were
      later erased and overwritten, making the handwritten note
      meaningless.

*) Add 64K words of control memory, so BASIC-3/COBOL can run
   OptionC.pdf in the jim/wang2200/docs/system/2200MVP_MaintenanceManual
   directory describes the upgrade to give 64KB of control ram and
   512KB of RAM.  0x8000 to 0x8FFF is a hole where the bootstram PROM lives.
   Don't make it configurable -- just give it all 64K to reduce UI clutter.

*) Maybe have an easy config mode and an expert mode:
      a) 2200T   w/ 32KB RAM, printer, two disk drives, KB + 64x16 screen
      b) 2200VP  w/ 64KB RAM, printer, two disk drives, KB + 80x24 screen
      c) 2200MVP w/512KB RAM, printer, two disk drives, 2236 MXD, one term
      d) expert mode

*) Document how to work around this problem in the README.

   the printer config allows picking either LPT1 or LPT2 as the real printer
   to stream to.  This doesn't work if the computer has a USB printer.
   using "net use LPT1: \\JIM-860\HP-920 /PERSISTENT:YES" does map LPT1 to the
   named network printer, but at least in my case, the printer doesn't model a
   simple ASCII printer.  It apparently is expecting some HP protocol or
   something.

   This guy wrote a lib to allow querying which printers are available,
   and returning properties about a given printer.
      http://hdrlab.org.nz/projects/wxwidgets-projects/custom-print-dialog-toolkit/
   It doesn't address the above point, it seems.

    + Go to "Devices and Printers" control panel.
    + select the "Add a printer" menu at the top.
    + specify "Add a local printer"
    + under "Use an existing port:", select the one corresponding to your USB printer
      ("USB001" in my case); press "Next"
    + it now asks to install the printer driver.  Under Manufacturer, pick "Generic".
      Under Printers, pick "Generic / Text Only"; press "Next"
    + select "use the driver that is currently installed" (at least, that is what I did);
      press "Next"
    + time to create a printer name.  I made mine "USB-ASCII"; press "Next"
    + from a dos prompt, type
        NET USE LPT2: \\<machine_name>\USB-ASCII /PERSISTENT:YES
      it should reply "The command completed successfully"
    + from the Wang 2200 emulator printer windows, select LPT2 as the real printer to
      direct output to
    + in my case, I had to do "SELECT LIST 015" to get the wang to put out a
      line feed after each carriage return.  The 215 device just ends each line
      with a CR and no LF.
    + if the program ends without filling the last page, you may need to send a
      HEX(0C) (page feed) to the printer to flush out the partial page.

*) the read and write routines go to great lengths to inline things,
   but they both have the expression (m_memsize_KB<<10).  That should
   be precomputed as m_memsize.  or should I just get rid of m_memsize_KB?

*) When changing configurations, currently I:
        - destroy current config
        - rebuild world
   Would it be cleaner to do the following?
        - build new world
        - on success, swap to new world, then destroy old world
        - on failure, report problem, and old world is still usable

*) notes on disk protocol and unimplemented commands:
    f:/jim/documents/wang2200/disk_protocol/notes.txt

*) when I run diags, say control mem tests, the test will often hang if
   I run the emulator in realtime mode, but runs OK if I am unregulated.
   what gives?  break during the apparent hang and see what the execution
   loop is doing.  enable trace dumping, I guess.
   A: it turns out it is polling (SH & 2), which is the "CRB" status bit,
      which indicates if the selected device is busy.  Hitting the keyboard
      a few times gets it past that log jam.  I'm not sure why that is
      required and why it only happens in speed regulated mode.

*) update the website (and build notes) with directions on how to make
   the thing such that it doesn't have DLL dependencies.  What a mess.
      1) declare "_BIND_TO_CURRENT_CRT_VERSION=1" in the wx libs that
         the applications uses, for the release versions of adv, base, core
      2) declare "_BIND_TO_CURRENT_CRT_VERSION=1" in the wangemu properties
      3) copy Microsoft.VC.CRT from
            /Program Files/Microsoft Visual Studio 9.0/VC/redist/x86
         to the top level emulator directory
   see
    http://www.microsoft.com/communities/newsgroups/en-us/default.aspx?dg=microsoft.public.vstudio.general&tid=2d0b8055-3fe2-482b-9fb2-731eb51859ee&cat=&lang=en&cr=US&sloc=&p=1

*) recover tapes
    - wang backup tapes are probably QIC-02
        http://www.lintech.org/comp-per/11MAGTAP.pdf
        http://www.qic.org/html/qicstan.html#02
      but wang had a wang-proprietary format mode
      DataStorageCabinetMaintenanceManual.741-1806.9-87.pdf, page 10-2, says
        storage capacity of 45 MB with 45-ft tape, which is compatible with
        the idea that a 600' tape would store up to 600 MB.
        the parts list, page 12-4, says the drive is 725-1481, vendor MT-2ST
        page 12-5 has hand written notes
            high density tape (45 60M)  725-1482-1/725-4055-1
            150M xtra density tape      725-7548 (teac mdl# CT600-N)
            teac 150M PROM (on drive w/wang id) 730-1774
      DS_DataStorageCabinetUsersManual.715-0740.5-87.pdf
        chapters 6 & 7 are useful
        chapter 7 has GIO sequences for each tape operation command
            decode them and see if they use wang proprietary format or not
            or perhaps these are communicating to the tape controller,
            and the tape controller them maps these to teac-native SCSI
            commands, in which case maybe I can't tell
        A-2 specifications:
            8000 bpi, 90 ips, 9 physical tracks
            elsehwere: 8 tracks for data, 9th track for directory
      jan van de veen has two DS cabinets
      http://mcbx.netne.net/computers/media/teac/index.htm says:
        This unit is communicating with a proprietary interface similar to
        SCSI, but incompatible with SCSI and requires a special interface
        card.
        This page also has a couple interesting links.
        There are some MT-2ST drives which are SCSI, some where are SCSI SE,
        some which are QIC-02.  Perhaps his statement is true for the model
        which he has.
    - adaptec AHA-2930LP scsi interface cards apparently work with win/7
        and are $15 on ebay

*) finally got a wang PC keyboard.  there are some extra keys, but the guess
   I made how they'd be expressed was wrong (see UiCrt_Keyboard.cpp).
   This is what the wx sample app "keyboard" sees:

                  no shift   shift    control   alt
    F11:          F11        S-F11    C-F11     A-F11
    F13:          ALT-F3     C-S-F3   C-A-F3    A-F3
    F14:          ALT-F4     C-S-F4   C-A-F4    A-F4
    F15:          ALT-F5     C-S-F5   C-A-F5    A-F5
    F16:          ALT-F6     C-S-F6   C-A-F6    A-F6
    CANCEL:       ALT-F7     C-S-F7   C-A-F7    A-F7
    HELP:         ALT-F8     C-S-F8   C-A-F8    A-F8
    GL:           ALT-F9     C-S-F9   C-A-F9    A-F9
    Erase/DecTab: ALT-F10    C-S-F10  C-A-F10   A-F10
    EXEC/END:     END        S-END    C-END     A-END

    maybe tie it in with the next bullet item.

*) make keyboard mapping configurable
    - requested by Mark Musen, who runs it on a mac under virtual PC.
      there is no pause/break (->HALT/STEP) key on that setup.

*) allow pasting text to the emulator from the clipboard.  should be easy.
   copying text from the screen is significantly more work, as I'd have
   to track start & end selection, account for scrolling, have some visual
   indication.

*) check out these tips on using wxWidgets under visual studio:
    http://www.litwindow.com/Knowhow/wxHowto/wxhowto.html

*) emulate "CPU running" light on keyboard

*) better BELL emulation.  and make it optional.

*) add a debugger/monitor
    - the VP disassembler doesn't match the assembler syntax as specified
      in the 2600 sw development manual.
      (2200MVP_ComputerArchitecture.11-79.pdf, pdf page 81 or so)

*) emulate plotter?  no point really without an interesting program.
   plotter commands:
        80 | p = start of plot command

        80 | t = step +x,+y
        80 | r = step +x,-y
        80 | s = step -x,+y
        80 | q = step -x,-y

        80 | v = step  0,-y
        80 | w = step  0,+y

        80 | x = step -x,0
        80 | y = step +x,0

        80 | z = move to zero position (user defined manually)
        80 | u = end of plot command

   The BASIC-2 manual mentions SELECT PLOT and says that the C driver
   type sends plotter commands in binary, speeding things up.  The manual
   doesn't describe PLOT!  But the 2200 type PLOT commands work.  I wonder
   if they have been augmented.  It would be nice to have a Plotter manual.

   the 2232 was a flatbed plotter.  in the docs/schematics/peripherals dir
   is 6337 -- which is the "pen control & command decoder" for this plotter.

*) emulate cassette tape?
   some information about it:
      http://www.wang2200.org/docs/internal/2200_TapeDriveSpecifications.2-73.pdf
      http://www.wang2200.org/docs/internal/2200_IO_Specifications.6-72.pdf

============================================================================
Misc
============================================================================

*) holy crap, read the message from Richard L Lockley, 8/20/2003 in the
   wang folder.  I never replied, until just now (10/8/08).  He claimed
   to have every wang document up to 1985.  Maybe he has 3300 docs.
    As of 2/2013:
        (314) 921-4109 (home #)
        7314 Elm Grove Ct
        Hazelwood, MO 63042-2008

*) notes about why MAT PRINT causes a hang on the 2200B ROMs.
   it turns out that the real hardware does too, according to Georg.

       6310.pdf (ALU): conn3, pin 10 has !ERG.  This goes to
            When is ERG active?
            It is a function of A[3:1], B[3:1], R[19:0]
            ERG = ((A==11xx) || (A==x11x) || (B==11xx) || (B==1x1x)) & "D0"
            D0 = R16 & !(!DSC &&  (!R17 ||  R19))
               = R16 &  (!DSC || !(!R17 ||  R19))
               = R16 &  (!DSC ||  ( R17 && !R19))
                 (I think D0=1 means decimal mode)
            So it seems that if one does a BCD op with operands that are
            out of range, it would have set ST3-1.  The schematic is wrong,
            either that or this is really weird, since the second A term
            fires on 6, 7, 14, 15 and lets 10 and 11 pass.  The B term seems
            correct.
       6311.pdf (I/O), conn3, pin 9.
            When ERG is active (low), it sets bit D2 (0010) of the ST3 latch,
            however the schematic shows this flop as not driving anything,
            and the mux that would have logically accepted ST3-1 instead
            is fed from L24A/!QD, which is latching !IB5 -- which is used
            to sense 80 char wide terminals vs 64 wide (other peripherals
            might use it too, but not that I know of).
        On the 6710 (2200T CPU), this signal is driven with a meaningless value.

        OK, so this isn't causing the mismatch.

        ====

        Dumping instructions after 10 MAT PRINT A<CR>,
            2200Tdbg.txt vs 2200Bdbg.txt
        cycle 2 of the first lines up with cycle 13 of the second.
        at cycle 40/51, 00AC is read and 05/04 is returned (why the difference?)
        instructions are in until cycle 665/676 where there is a ucode difference:
            B 01F8 / SB 006D
        Things sync up again a while later (search on corresponding /RAM.ROM),
        and stay in sync for the most part until cycle 4685/4683, which is
            MV CL,PC2 ; MV CH,PC1 ; MV F5,PC4; MV F4,PC3
        in the 2200T case, PC=4A0B, for 2200B, it becomes 26FD.
        Then at cycle 4698/4696, "TPI" (transfer PC to IC) causes major divergence:
            2200T goes to 4A0B (MAT handler), while
            2200B goes to 26FD:
                26FD: MVI 4,PC1
                26FE: B   7E0C  (inside patch routines)
                7E0C: B   3400
                3400: BNE 0F,0,34FF  (opcode=FFFFF; really meaningless)
                34FF: BNE 0F,0,34FF  (opcode=FFFFF; really meaningless)
        Looking at the constant rom tables, the entry for MAT is
            2200T: 4A 0B   03  4D 41 54  A8
                   handler len M  A  T   token
            2200B: 26 FD   03  4D 41 54  A8
                   handler len M  A  T   token
        So it looks like the emulator is doing exactly the right thing;
        the question is why does the constant ROM have an entry for MAT,
        or at least why does it jump to a patch routine which then jumps to
        non-existant code vs an error handler.

        A: the real hardware does the same thing.  The atom table points
           to a non-populated ROM location, and death ensues.

*) DATAMATH  CALCULATOR  MUSEUM (www.datamath.org) has a tiny accuracy
   benchmark that they run on all the calculators they come across.
   In Wang BASIC it is expressed as:

    10 SELECT D
    20 PRINT ARCSIN(ARCCOS(ARCTAN(TAN(COS(SIN(9))))))

   Here are the results:
    Wang 2200T:  9.00000222872
    Wang 2200VP: 9.000000590471

*) this doesn't have to go onto the web site, but since I collected the
   data, I don't want to just delete it.

   After running some experiments, it would appear that the CS/386 interpreter
   is a different implementation altogether, not a microcode binary translator.
      + PRINT ARCSIN(ARCCOS(ARCTAN(TAN(COS(SIN(9))))))
          VP BASIC 2.3:
              9.000000590471
          MULTI-USER BASIC-2 3.5:
              9.000000590471
          MULTI-USER BASIC-2/386 1.3.00:
              9.000000586479
      + PRINT RND(0), RND(1)
          VP BASIC 2.3:
              .1584625767084  .361319611557
          MULTI-USER BASIC-2 3.5:
              .1584625767084  .361319611557
          MULTI-USER BASIC-2/386 1.3.00:
              .1584625767084  .5930297180313
      + Enter
            10 DATA 1,2,3,    4,5,6
        On the VP-based CPUs, the extra spaces are preserved;
        on the CS/386, the extra spaces are lost.

============================================================================
Suggestions for wx improvements
============================================================================

*) wxMAC issues  (as of 2.6.1)
    + DrawText() on a 1bpp wxMemoryDC doesn't work
    + wxStatusBar::SetMinHeight() doesn't seem to work
    Both are fixed if the font has propery SetNoAntiAliasing().
