============================================================================
Emulator TODO list
============================================================================

*) cpu2200{t,vp} holds a ref called m_sys which is a pointer back
   to the system object.  it should be made a pointer to match
   other things.  it didn't be a smart pointer, though, as the
   thing it points to is a singleton.

*) the Scheduler class callback list should hold std::weak_ptr to
   the callback objects.  when the scheduling code needs to use such
   a pointer, it should first test if it is .expired(), and if not,
   then use .lock() to obtain a pointer to the object.

   hmm, the problem is the callback isn't to a shared object; it is
   typically a pointer to a member function of a shared object. this
   would complicate the calling site.  there is the concept of a shared
   pointer aliasing constructor, where the new pointer is to a member
   of the shared object but uses the control block of the whole object.
   but there doesn't seem to be a similar concept for weak pointers.

   I asked for clarity on reddit and got these replies:
      https://www.reddit.com/r/cpp/comments/5m037m/why_isnt_there_an_aliasing_constructor_for/

   This exposes that things don't work in my own code as I claimed.
   I thought that I explicitly Kill()'d all timers when I wanted to reconfigure
   the world, but I don't.  System2200::breakdown_cards() just deletes the
   objects.  That means that the objects aren't actually destroyed when I
   think they are; they are destroyed when the scheduler is destroyed.

*) I haven't really grasped the use and purpose of unique_ptr.
   I still have a lot of raw pointers around, eg IoCard.cpp has a factory
   which creates and returns IoCard* values.  But after reading a bit more,
   the general practice should be to use unique_ptr just about everywhere,
   and that functions get get passed a pointer are receiving a reference
   to that unique pointer, eg
        void inc_baz( std::unique_ptr<foo> &p )
        {
            p->baz++;
        }
   somefunction can use that object without grabbing the pointer ownership.
   Also, when a function creates a unique pointer and returns it, the
   return automatically is treated as a move (as it makes no sense to
   retain ownership inside the function).

   In
        https://herbsutter.com/2013/05/30/gotw-90-solution-factories/
   Herb Sutter says factory functions should return a unique_ptr<foo>
   if the factory doesn't maintain any bookeeping knowledge of the
   created object, or a shared_ptr<foo> if the factory has to keep
   track of it for some reason. My card factory certainly doesn't.

   But in "smart pointer parameters":
        https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/
   he says that in general function paramters should accept raw pointers
   or references.  Using std::unique_ptr<foo>& unnecessarily restricts the
   routine to only accepting one type of pointer, and the subroutine
   (in general) shouldn't care about the ownership type.  That seems to
   contradict this talk by Sutter (which is 3 years more recent):
        https://www.youtube.com/watch?v=JfmTagWcqoE
   That same video (at around 38:00) says that to avoid cycles, lower
   levels of an ownership hierarcy shouldn't hold pointers to a higher level,
   which is exactly what I do.  He says th fix is to store a weak_ptr to
   the higher level.  (same with timer callbacks, most likely)
   ...
   hmm, because of timer callback, then it seems like I really don't have
   a unique_ptr situation with cards (in general).

   Right now shared_ptr is used in two places:
     (1) "using spTimer = std::shared_ptr<Timer>;"
     (2) UiCrt.h has "shared_ptr<wxSound> m_beep;"

   http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#a-namerr-smartptrparamar30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics
   which is dec 2016, so it should reflect latest thinking, is that
   raw T* or T& should be used if the subroutine isn't changing ownership,
   that is, it uses it but doesn't store a copy or need to reseat the
   pointer.  Use std::shared_ptr<T> if the subroutine is going to keep
   a copy, or std::unique_ptr<T> if it is going to take ownership.
   http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#a-namerr-sharedptrparam-ownerar34-take-a-sharedptrwidget-parameter-to-express-that-a-function-is-part-owner

*) in the same talk (10 minutes in), Sutter says the PIMPL pointer should be
     template<class T>
     using Pimpl = const unique_ptr<T>;
     ...
     class MyClass {
       class Impl;  // defined in .cpp
       Pimpl<impl> pimpl;
     }

*) use smart pointers instead of raw pointers
   !! look for "delete" occurrences; if these were smart pointers,
   just setting the pointer to nullptr would automatically free the resource.
   Convert these to unique_ptr or shared_ptr when it makes sense.

    IoCardDisk.h
        m_d[drive]
    SysCfgState.h
        m_slot[slot].cardCfg
    System2200.h
        m_cardInSlot[n]
        m_cpu
        m_scheduler
        m_config

*) continuing the above theme, the card factory has a really ugly feature.
   what is the right & clean way to do this?
        IoCard *
        IoCard::makeTmpCard(card_t type)
        {
        // FIXME: this is sinful to pass 0 to a ref!
            return makeCardImpl( *(Scheduler*)0, *(Cpu2200*)0, type, 0x000, -1,
                                 (CardCfgState *)0 );
        }
   who uses makeTmpCard()?
      CardInfo::getCardTypeFromName(const string &name)
      CardInfo::getCardName(IoCard::card_t cardtype)
      CardInfo::getCardDesc(IoCard::card_t cardtype)
      CardInfo::getCardBaseAddresses(IoCard::card_t cardtype)
      CardInfo::isCardConfigurable(IoCard::card_t cardtype)
      CardInfo::isCardCfgState(IoCard::card_t cardtype)
      SysCfgState::editCardConfig(int slot)

   We could require that each IoCardFoo have static class functions
   to return the above info, then make CardInfo have a case statement
   to call the right one for each function above, but that is violating
   DRY principles.

   Making the cards hold a weak_ptr to cpu and scheduler is a bit better
   than the existing scheme of setting them up with a nullptr reference,
   which is supposed to be illegal (refs are never null).

*) 10 PRINT HEX(07);:GOTO 10
   RUN
   doesn't make any sound and kind of hands. CTRL-C eventually stops it,
   but it takes awhile.  Doing PRINT HEX(0707070707070707070707) sounds
   the same as PRINT HEX(07).  Is there something in the hardware which
   ensures a given HEX(07) takes at least a certain amount of time?
   I would guess each HEX(07) triggers a one-shot which gates a 1KHz
   oscillator, and subsequent HEX(07) will either retrigger the one-shot,
   or are ignored.  check the schematic.  Then change the logic to match,
   either by making the wav file play in a loop and then using a timer
   event to schedule when to turn it off (perhaps canceling and rescheduling
   if another hex 07 arrives), or by always letting it run to completion
   and ignoring new hex(07) if one arrives while the previous is playing.

*) None of the recent changes has been compiled on OSX, so most likely there
   will be problems.  Once the code is somewhat stable under windows,
   build it on OSX and iron out the problems.

*) add terminal mux emulation and terminal emulation so I can run MVP OS's

   - disassemble MXD code to understand behavior better
        C:\Users\Jim\Documents\wang2200\boards\LVP box\7291_dasm\

   - MXC,D,E notes: c:/users/jim/documents/wang2200/boards/terminal_mux_notes.txt

   - immediate code changes
      - route keyboard input when the focus is on a given window to the
        associated keyboard port when there is a MXD too
	+ IoCardKeyboard.cpp contans core_sysKeystroke() function.
          this dispatches it to the IoCardKeyboard::receiveKeystroke(),
          which isn't able to route keys to IoCardTermMux.
          This needs to be generalized.  Perhaps the keyboard or TermMux
          should pass a keystroke handler callback to CrtFrame, which does
          the dispatching.  This would use <function> to do the callback.
        + the problem is that at the the frame is created in IoCardDisplay
          by calling UI_initCrt() (which then calls new Crt), but at that
	  point we don't know what the associated keyboard is. on each
	  keystroke, Crt::OnKeyDown (in UiCrt_Keyboard.cpp) calls
	  m_parent->GetTiedAddr(), which returns UiCrtFrame->m_assoc_kb_addr.
	  that association is set in these cases:
	    . from the .ini file on start up
	    . defaults to 0x01 if the .ini isn't valid
	    . user manually changes if if there are multiple KB devices
	  that association is found 
        + the tied_keyboard setting is read during getDefaults() in UiCrtFrame
but tied_keyboard doesn't make sense for term mux because it is not an
independent address
        + the TermMux type does know the mapping at creation time.
          perhaps we should mandate that the mapping must be known at
          creation time, and for old display types it is always 0x01 and
          remove the possibility (at least for now) of unusual mappings.

   - the hardware has an 8b "RBI" register (ready/busy), one bit for each
     logical port.  Software maintains the logical readiness of each
     port, but hardware takes care of muxing out the appropriate bit to the
     RBI bus signal.  note that the flop with these bits is cleared on reset
     but also any time the OB1-8 bus is read from the latch; that is, after
     OBS or CBS, reading the data latch clears the OBS/CBS strobe latches
     and it also clears the RBI[7:1] latch (== not ready), thus the Z80
     must write the latch to indicate ready again.

     does it makes sense for the the emulation to do something similar?
     m_cpu.setDevRdy() is how it currently returns ready status.

     This is what tells ucode that the device is ready to accept another
     OBS or CBS strobe.
        Understand this better:
            on the MXE schematic, if there is no OBS or CBS input pending
            and the card is selected, the !RBI mux "!STB" input is low,
            then it lets the mux drive !RBI.  But if (OBS or CBS) is pending
            AND latched AB3=1 then !RBI is driven high (not ready).
            why "&& AB3"?
                0: not mapped
                1: keyboard (in vp mode), doesn't accept CBS/OBS
                2: read status
                3: MXD: unused; MXE: read bytes from screen dump
            OK, so OBS/CBS aren't used in this range, but then && AB3 
            is a don't care, no?

     Cards drive:   RBI, IBS, IB1-9
     Cards receive: ABS, AB1-8, CBS, OBS, OB1-8, CPB
            CPB indicates when the host is waiting for input
                ucode only ever sets this to "!busy"
                when a card drives IBS, it resets CBP back to the busy state
            RBI indicates when the card is ready for OBS/CBS input
                !RBI=0 is ready, !RBI=1 is busy

   - currently the division is
        + IoCardKeyboard
        + IoCardDisplay
        + UiCrtFrame
            + UiCrtStatusBar
            + UiCrtConfigDlg
            + UiCrt
                + UiCrt_Charset.h
                + UiCrtErrorDlg
		+ UiCrt_Keyboard
     IoCardKeyboard.cpp has a fair amount of script processing logic in it,
        and I don't want to duplicate this for dumb & smart terminal modes
     UiCrtFrame constructor takes title, screen_size, io_addr.
        To reuse this, it needs a more generic attachment than io_addr;
        it needs to either me an io_addr port N of term mux at io_addr nn.
     Crt state is saved in the .ini file by ui/CRT-nn, where nn is the addr;
        this needs to be generalized
     The CrtFrame displays disk icons and activity, but in mux mode,
        there really shouldn't be a 1:1 mapping.  However, in the typical
        use case of one term, it is most useful.
     The CrtFrame logic enables some config options only on the "primary" crt,
        which historically has been the one at io_addr=05.  Rethink this.
     Config dialog needs to allow term mux configurations.
     UiCrt_Keyboard is really part of UiCrt, and provides the OnChar/OnKeyDown
        handling.  When it recognizes a key, it calls
            core_sysKeystroke(tied io_addr, key)
        which then routes it to the associated IoCardKeyboard function.
        The three related functions are
            core_sysKeystroke(io_addr, key)
            core_invokeScript(io_addr, filename)
            core_isKbInScriptMode(io_addr)  // used to disable some fcns while processing the script
        IoCardKeyboard::check_keyready() is a private function, and one of
            the things it does is poll the script.  To move this into the
            UiCrt logic would require IOCardKeyboard to move that script
            logic into UiCrt and have check_keyready() poll it there.
        Huh -- the logic grabs the next char from the script file only
            after the keystroke buffer is empty, but then waits 50ms before
            reporting it because something breaks in the ucode without it.
            (50ms of simulated time, not realtime)

    - emulating MXD, not MXE, because MXE runs only >= OS ver 2.4

    - interesting: when in mvp mode, port 01 appears as always busy
      (p10 of 2236MXE_Documentation.8-83.pdf)

    - allow term MUX to connect to a real serial port
        - a mac/linux/win lib: http://sigrok.org/wiki/Libserialport
        - http://wjwwood.io/serial/
        - https://iftools.com/opensource/ctb.en.php
        - windows+linux only: http://www.teuniz.net/RS-232/

    - section 8 of 2200MVP_MaintenanceManual.729-0584-A.1-84.pdf lists
      what is involved to upgrade a VP to an MVP.  part of it requires
      changing the boot ROM ucode to deal with the larger program memory.
      do I have these boot ROMs?
         double check boards/other boards/6789 and see if those ROMs match
         what the emulator uses
      the MVP service manual section 8.2 (page 8-2) says
          2200 VP/MVP Bootstrap Release 2.2 has been incorporated by ECN
          #9772.  For a system to operate with an expanded memory, this ECN
          must be performed.  The old PROMS on the 210-6789 must be replaced
          with the following:
              378-2045R1 = L27
              378-2046R1 = L28
              378-2047R1 = L29
      the 6789 board that I got the 2nd set of bootstrap PROMs from
      are windowed eproms without official Wang revision numbers.
      handwritten on the chips are the following:
          L29 says "2047"
          L28 says "2046R5"
          L27 says "2045R5"
      It is possible that the contents were R5, but the EPROMs were
      later erased and overwritten, making the handwritten note
      meaningless.

*) on toolbar, add superscript to some SF keys in (M)VP mode:
     SF4: END
     SF5: down arrow  (useful when the edited line wraps)
     SF6: up arrow    (useful when the edited line wraps)
     SF7: BEGIN
   Also, make up/down arrow keys map to SF5 and SF6

*) improved 2236 terminal emulation

    - add smart terminal commands that I've skipped
        - make it so FB Cx actually causes a x/6 second delay
        - add command to return terminal ID
        - screen input (capture)

    - test some corner case on the real terminal
      what happens if there is an incorrect escape sequence:
      at what point are the bytes swallowed, or are they passed through?

    - Fasstcom Terminal Specs v1.0.pdf, pdf page 8 says
      "... the terminal must always transmit a HEX(F8F9) every 3 to 5 seconds
       whenever it is ready to receive new data during idle time.
       This is called the constant poll."
      The emulated terminal doesn't.  Should it?  Is this just to compensate
      for the fact that the serial link wasn't perfect, so this avoided
      accidently dropping a XON character and freezing the handshake?

    - 742-0903.MNL.IntegratedTerminal2236DW.85-02-27.pdf, pdf page 68 says
          2236DW and 2236DW have mostly the same character generators,
          except for characters 5F/7F/80/8D/8F/DF/FF

    - the weird thing where inverse mode causes video to be lit
      either when the current dot is 0 or the previous dot was 0
      gets tricky in the presence of box line graphics.
        1) vert is kind of screwed because it could interact with the
           glyph bitmap under it
        2) horizontal box lines should be stippled if normal video,
           but solid black if inverse mode
      the fix is either to buy into full-screen at once blurring,
      or to double the fontmap to have with/without vertical bar
    - dot stream is gated by pixclk.  not easily do-able in 2:1 dot mode
    - get rid of 1x1 dot matrix mode -- doesn't model the real hw,
      isn't readable.
    - write an opengl shader which uses the attr/char maps as a texture
      to generate the output in parallel. can also add contrast, brightness,
      blur, TV warp, etc
          Js amiga emulator using webgl for display:
              http://scriptedamigaemulator.net
          Stack overflow: using webgl to map palettized display to rgb display
              http://stackoverflow.com/questions/19695658/emulating-palette-based-graphics-in-webgl-v-s-canvas-2d
          apple II js w/webgl rendering option:
              http://porkrind.org/a2/
      in many ways this is simpler, in that it only has to deal with one
      single 10x22 dot format and can then stretch to the current screen size,
      instead of having 1:1, 1:2, 2:4 dot matrix modes.

    - pre-blurring the char set to a glyph map, then blitting to the display
      works OK, except the cursor isn't blurred because it is dynamic, and
      edges of block graphic characters are noticable because the blurring
      kernel needs to span across characters.  it also interacts poorly
      with the box line graphics overlay.

      render unblurred and then use OGL to do the blurring.  this has the
      benefit of offering flexible scaling at low cost, and perhaps other
      video generation defect emulation.

    - the smart terminal menu should have an option to reset just the terminal

    - allow running terminal as a separate process
        - running in process is easier to manage for the casual user, though
        - actual serial port connection
        - running via sockets, allowing local or remote connection
        - perhaps as a javascript app, with multiple terminals as tabs?

*) Add 64K words of control memory, so BASIC-3/COBOL can run
   OptionC.pdf in the jim/wang2200/docs/system/2200MVP_MaintenanceManual
   directory describes the upgrade to give 64KB of control ram and
   512KB of RAM.  0x8000 to 0x8FFF is a hole where the bootstram PROM lives.
   Don't make it configurable -- just give it all 64K to reduce UI clutter.

*) Maybe have an easy config mode and an expert mode:
      a) 2200T   w/ 32KB RAM, printer, two disk drives, KB + 64x16 screen
      b) 2200VP  w/ 64KB RAM, printer, two disk drives, KB + 80x24 screen
      c) 2200MVP w/512KB RAM, printer, two disk drives, 2236 MXD, one term
      d) expert mode

*) do a memory leak check towards the end of development

    - installed Dr. Memory, seems easy to use, no source changes and does
      much more than just detecting leaks.  http://www.drmemory.org/

*) Document how to work around this problem in the README.

   the printer config allows picking either LPT1 or LPT2 as the real printer
   to stream to.  This doesn't work if the computer has a USB printer.
   using "net use LPT1: \\JIM-860\HP-920 /PERSISTENT:YES" does map LPT1 to the
   named network printer, but at least in my case, the printer doesn't model a
   simple ASCII printer.  It apparently is expecting some HP protocol or
   something.

   This guy wrote a lib to allow querying which printers are available,
   and returning properties about a given printer.
      http://hdrlab.org.nz/projects/wxwidgets-projects/custom-print-dialog-toolkit/
   It doesn't address the above point, it seems.

    + Go to "Devices and Printers" control panel.
    + select the "Add a printer" menu at the top.
    + specify "Add a local printer"
    + under "Use an existing port:", select the one corresponding to your USB printer
      ("USB001" in my case); press "Next"
    + it now asks to install the printer driver.  Under Manufacturer, pick "Generic".
      Under Printers, pick "Generic / Text Only"; press "Next"
    + select "use the driver that is currently installed" (at least, that is what I did);
      press "Next"
    + time to create a printer name.  I made mine "USB-ASCII"; press "Next"
    + from a dos prompt, type
        NET USE LPT2: \\<machine_name>\USB-ASCII /PERSISTENT:YES
      it should reply "The command completed successfully"
    + from the Wang 2200 emulator printer windows, select LPT2 as the real printer to
      direct output to
    + in my case, I had to do "SELECT LIST 015" to get the wang to put out a
      line feed after each carriage return.  The 215 device just ends each line
      with a CR and no LF.
    + if the program ends without filling the last page, you may need to send a
      HEX(0C) (page feed) to the printer to flush out the partial page.

*) the read and write routines go to great lengths to inline things,
   but they both have the expression (m_memsize_KB<<10).  That should
   be precomputed as m_memsize.  or should I just get rid of m_memsize_KB?

*) When changing configurations, currently I:
        - destroy current config
        - rebuild world
   Would it be cleaner to do the following?
        - build new world
        - on success, swap to new world, then destroy old world
        - on failure, report problem, and old world is still usable

*) notes on disk protocol and unimplemented commands:
    f:/jim/documents/wang2200/disk_protocol/notes.txt

*) when I run diags, say control mem tests, the test will often hang if
   I run the emulator in realtime mode, but runs OK if I am unregulated.
   what gives?  break during the apparent hang and see what the execution
   loop is doing.  enable trace dumping, I guess.
   A: it turns out it is polling (SH & 2), which is the "CRB" status bit,
      which indicates if the selected device is busy.  Hitting the keyboard
      a few times gets it past that log jam.  I'm not sure why that is
      required and why it only happens in speed regulated mode.

*) update the website (and build notes) with directions on how to make
   the thing such that it doesn't have DLL dependencies.  What a mess.
      1) declare "_BIND_TO_CURRENT_CRT_VERSION=1" in the wx libs that
         the applications uses, for the release versions of adv, base, core
      2) declare "_BIND_TO_CURRENT_CRT_VERSION=1" in the wangemu properties
      3) copy Microsoft.VC.CRT from
            /Program Files/Microsoft Visual Studio 9.0/VC/redist/x86
         to the top level emulator directory
   see
    http://www.microsoft.com/communities/newsgroups/en-us/default.aspx?dg=microsoft.public.vstudio.general&tid=2d0b8055-3fe2-482b-9fb2-731eb51859ee&cat=&lang=en&cr=US&sloc=&p=1

*) recover tapes
    - wang backup tapes are probably QIC-02
        http://www.lintech.org/comp-per/11MAGTAP.pdf
        http://www.qic.org/html/qicstan.html#02
      but wang had a wang-proprietary format mode
      DataStorageCabinetMaintenanceManual.741-1806.9-87.pdf, page 10-2, says
        storage capacity of 45 MB with 45-ft tape, which is compatible with
        the idea that a 600' tape would store up to 600 MB.
        the parts list, page 12-4, says the drive is 725-1481, vendor MT-2ST
        page 12-5 has hand written notes
            high density tape (45 60M)  725-1482-1/725-4055-1
            150M xtra density tape      725-7548 (teac mdl# CT600-N)
            teac 150M PROM (on drive w/wang id) 730-1774
      DS_DataStorageCabinetUsersManual.715-0740.5-87.pdf
        chapters 6 & 7 are useful
        chapter 7 has GIO sequences for each tape operation command
            decode them and see if they use wang proprietary format or not
            or perhaps these are communicating to the tape controller,
            and the tape controller them maps these to teac-native SCSI
            commands, in which case maybe I can't tell
        A-2 specifications:
            8000 bpi, 90 ips, 9 physical tracks
            elsehwere: 8 tracks for data, 9th track for directory
      jan van de veen has two DS cabinets
      http://mcbx.netne.net/computers/media/teac/index.htm says:
        This unit is communicating with a proprietary interface similar to
        SCSI, but incompatible with SCSI and requires a special interface
        card.
        This page also has a couple interesting links.
        There are some MT-2ST drives which are SCSI, some where are SCSI SE,
        some which are QIC-02.  Perhaps his statement is true for the model
        which he has.
    - adaptec AHA-2930LP scsi interface cards apparently work with win/7
        and are $15 on ebay

*) finally got a wang PC keyboard.  there are some extra keys, but the guess
   I made how they'd be expressed was wrong (see UiCrt_Keyboard.cpp).
   This is what the wx sample app "keyboard" sees:

                  no shift   shift    control   alt
    F11:          F11        S-F11    C-F11     A-F11
    F13:          ALT-F3     C-S-F3   C-A-F3    A-F3
    F14:          ALT-F4     C-S-F4   C-A-F4    A-F4
    F15:          ALT-F5     C-S-F5   C-A-F5    A-F5
    F16:          ALT-F6     C-S-F6   C-A-F6    A-F6
    CANCEL:       ALT-F7     C-S-F7   C-A-F7    A-F7
    HELP:         ALT-F8     C-S-F8   C-A-F8    A-F8
    GL:           ALT-F9     C-S-F9   C-A-F9    A-F9
    Erase/DecTab: ALT-F10    C-S-F10  C-A-F10   A-F10
    EXEC/END:     END        S-END    C-END     A-END

    maybe tie it in with the next bullet item.

*) make keyboard mapping configurable
    - requested by Mark Musen, who runs it on a mac under virtual PC.
      there is no pause/break (->HALT/STEP) key on that setup.

*) allow pasting text to the emulator from the clipboard.  should be easy.
   copying text from the screen is significantly more work, as I'd have
   to track start & end selection, account for scrolling, have some visual
   indication.

*) check out these tips on using wxWidgets under visual studio:
    http://www.litwindow.com/Knowhow/wxHowto/wxhowto.html

*) emulate "CPU running" light on keyboard

*) better BELL emulation.  and make it optional.

*) add a debugger/monitor
    - the VP disassembler doesn't match the assembler syntax as specified
      in the 2600 sw development manual.
      (2200MVP_ComputerArchitecture.11-79.pdf, pdf page 81 or so)

*) emulate plotter?  no point really without an interesting program.
   plotter commands:
        80 | p = start of plot command

        80 | t = step +x,+y
        80 | r = step +x,-y
        80 | s = step -x,+y
        80 | q = step -x,-y

        80 | v = step  0,-y
        80 | w = step  0,+y

        80 | x = step -x,0
        80 | y = step +x,0

        80 | z = move to zero position (user defined manually)
        80 | u = end of plot command

   The BASIC-2 manual mentions SELECT PLOT and says that the C driver
   type sends plotter commands in binary, speeding things up.  The manual
   doesn't describe PLOT!  But the 2200 type PLOT commands work.  I wonder
   if they have been augmented.  It would be nice to have a Plotter manual.

   the 2232 was a flatbed plotter.  in the docs/schematics/peripherals dir
   is 6337 -- which is the "pen control & command decoder" for this plotter.

*) emulate cassette tape?
   some information about it:
      http://www.wang2200.org/docs/internal/2200_TapeDriveSpecifications.2-73.pdf
      http://www.wang2200.org/docs/internal/2200_IO_Specifications.6-72.pdf

============================================================================
Misc
============================================================================

*) holy crap, read the message from Richard L Lockley, 8/20/2003 in the
   wang folder.  I never replied, until just now (10/8/08).  He claimed
   to have every wang document up to 1985.  Maybe he has 3300 docs.
    As of 2/2013:
        (314) 921-4109 (home #)
        7314 Elm Grove Ct
        Hazelwood, MO 63042-2008

*) notes about why MAT PRINT causes a hang on the 2200B ROMs.
   it turns out that the real hardware does too, according to Georg.

       6310.pdf (ALU): conn3, pin 10 has !ERG.  This goes to
            When is ERG active?
            It is a function of A[3:1], B[3:1], R[19:0]
            ERG = ((A==11xx) || (A==x11x) || (B==11xx) || (B==1x1x)) & "D0"
            D0 = R16 & !(!DSC &&  (!R17 ||  R19))
               = R16 &  (!DSC || !(!R17 ||  R19))
               = R16 &  (!DSC ||  ( R17 && !R19))
                 (I think D0=1 means decimal mode)
            So it seems that if one does a BCD op with operands that are
            out of range, it would have set ST3-1.  The schematic is wrong,
            either that or this is really weird, since the second A term
            fires on 6, 7, 14, 15 and lets 10 and 11 pass.  The B term seems
            correct.
       6311.pdf (I/O), conn3, pin 9.
            When ERG is active (low), it sets bit D2 (0010) of the ST3 latch,
            however the schematic shows this flop as not driving anything,
            and the mux that would have logically accepted ST3-1 instead
            is fed from L24A/!QD, which is latching !IB5 -- which is used
            to sense 80 char wide terminals vs 64 wide (other peripherals
            might use it too, but not that I know of).
        On the 6710 (2200T CPU), this signal is driven with a meaningless value.

        OK, so this isn't causing the mismatch.

        ====

        Dumping instructions after 10 MAT PRINT A<CR>,
            2200Tdbg.txt vs 2200Bdbg.txt
        cycle 2 of the first lines up with cycle 13 of the second.
        at cycle 40/51, 00AC is read and 05/04 is returned (why the difference?)
        instructions are in until cycle 665/676 where there is a ucode difference:
            B 01F8 / SB 006D
        Things sync up again a while later (search on corresponding /RAM.ROM),
        and stay in sync for the most part until cycle 4685/4683, which is
            MV CL,PC2 ; MV CH,PC1 ; MV F5,PC4; MV F4,PC3
        in the 2200T case, PC=4A0B, for 2200B, it becomes 26FD.
        Then at cycle 4698/4696, "TPI" (transfer PC to IC) causes major divergence:
            2200T goes to 4A0B (MAT handler), while
            2200B goes to 26FD:
                26FD: MVI 4,PC1
                26FE: B   7E0C  (inside patch routines)
                7E0C: B   3400
                3400: BNE 0F,0,34FF  (opcode=FFFFF; really meaningless)
                34FF: BNE 0F,0,34FF  (opcode=FFFFF; really meaningless)
        Looking at the constant rom tables, the entry for MAT is
            2200T: 4A 0B   03  4D 41 54  A8
                   handler len M  A  T   token
            2200B: 26 FD   03  4D 41 54  A8
                   handler len M  A  T   token
        So it looks like the emulator is doing exactly the right thing;
        the question is why does the constant ROM have an entry for MAT,
        or at least why does it jump to a patch routine which then jumps to
        non-existant code vs an error handler.

        A: the real hardware does the same thing.  The atom table points
           to a non-populated ROM location, and death ensues.

*) DATAMATH  CALCULATOR  MUSEUM (www.datamath.org) has a tiny accuracy
   benchmark that they run on all the calculators they come across.
   In Wang BASIC it is expressed as:

    10 SELECT D
    20 PRINT ARCSIN(ARCCOS(ARCTAN(TAN(COS(SIN(9))))))

   Here are the results:
    Wang 2200T:  9.00000222872
    Wang 2200VP: 9.000000590471

*) this doesn't have to go onto the web site, but since I collected the
   data, I don't want to just delete it.

   After running some experiments, it would appear that the CS/386 interpreter
   is a different implementation altogether, not a microcode binary translator.
      + PRINT ARCSIN(ARCCOS(ARCTAN(TAN(COS(SIN(9))))))
          VP BASIC 2.3:
              9.000000590471
          MULTI-USER BASIC-2 3.5:
              9.000000590471
          MULTI-USER BASIC-2/386 1.3.00:
              9.000000586479
      + PRINT RND(0), RND(1)
          VP BASIC 2.3:
              .1584625767084  .361319611557
          MULTI-USER BASIC-2 3.5:
              .1584625767084  .361319611557
          MULTI-USER BASIC-2/386 1.3.00:
              .1584625767084  .5930297180313
      + Enter
            10 DATA 1,2,3,    4,5,6
        On the VP-based CPUs, the extra spaces are preserved;
        on the CS/386, the extra spaces are lost.

============================================================================
wxBitmap vs wxImage refresher
============================================================================
In short,

    wxBitmap is a platform-dependent image format
    wxImage  is a platform-independent image format

wxImage is just a buffer of RGB bytes with an optional buffer for the alpha
bytes. It is all generic, platform independent and image file format
independent code. It includes generic code for scaling, resizing, clipping,
and other manipulations of the image data.

OTOH, wxBitmap is intended to be a wrapper of whatever is the native image
format that is quickest/easiest to draw to a DC or to be the target of the
drawing operations performed on a wxMemoryDC.

By splitting the responsibilities between wxImage/wxBitmap like this then
it's easier to use generic code shared by all platforms and image types for
generic operations and platform specific code where performance or
compatibility is needed.

--- also

If you need direct access the bitmap data instead going through drawing to
it using wxMemoryDC you need to use the wxPixelData class (either
wxNativePixelData for RGB bitmaps or wxAlphaPixelData for bitmaps with an
additionally alpha channel).

--- also

Implemented on Windows, GTK+ and OS X:

    wxNativePixelData: Class to access to wxBitmap's internal data without
		       alpha channel (RGB).
    wxAlphaPixelData: Class to access to wxBitmap's internal data with
		      alpha channel (RGBA).

Implemented everywhere:

    wxImagePixelData: Class to access to wxImage's internal data with
		      alpha channel (RGBA).

wxMSW note: efficient access is only possible to the bits of the so called
device independent bitmaps (DIB) under MSW. To ensure that wxBitmap uses a
DIB internally and not a device dependent bitmap (DDB), you need to pass an
explicit depth to its ctor, i.e. either 24 or 32, as by default wxBitmap
creates a DDB of the screen depth.

--- final thoughts

That explains some things, but then why does it barf under MSW with an
explicit bitmap depth of 32 and using wxAlphaPixelData?

-----
vim: et ts=8 sw=4
