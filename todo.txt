============================================================================
Emulator TODO list
============================================================================

*) master list of priorities:
   implement flow control from terminal to mxd
       there must be a rx fifo (from the terminals perspective) so it can
       keep receiving characters while it is waiting on the SELECT P delay,
       so I guess it should also be modeled in IoCardTermMux. In real life
       the fifo is also used when the terminal is decompressing runs of
       bytes, but in the emulator those are handled instantly.
       the problem is that there is no flow control from UiCrt to
       IoCardTermMux -- and IoCardTermMux can't tell when a FBCx sequence
       is sent (unless it too parses the byte stream).  yuck.

       a better solution (?) is to separate out the core terminal & display
       logic into gui-free code (essentialy the 2nd half of UiCrt.cpp) and
       let UiCrt handle just the display of the state of that thing.  I'd need
       to work out whether Crt pulls state from the core or or the core pushes
       state.  Probably the pull model is most natural.

       the terminal keyboard fifo and half the uart delay model could be
       moved into that Terminal object, as well as the keyboard remapping.

       IoCardTermMux currently calls UI_initCrt.  Perhaps it should instance
       a Terminal, and that calls UI_initCrt.  How much plumbing is needed
       for this? Does the model work for the 2200T scenario where a keyboard
       card is independent of a display card? how is information routed?

       add "crt stop" when it hits certain fullness thresholds
          2536DWTerminalAndTerminalControllerProtocol.pdf, pdf page 3
          it isn't clear to me how the accounting is done.  when the terminal
          gets a compressed run, is the count before or after expansion?
       add auto "crt go" when it drops under 30 chars (see above pdf) or
          when under threshold every 3 seconds
       verify eg "SELECT P6" works
       submit
   clean up mxd script flow control; submit
   get rid of tied keyboard thing -- unnecessary generalization
   add mvp/vlsi cpu and memory options; submit
   decide on a consistent set of naming conventions and stick to them
      hey, code.txt already has one.  study it.
   ... then review the priorities again

*) as an experiment, I tried creating two MXD cards
   the 2nd terminal also claims to be "term 1" on the titlebar.
   booting MVP 3.5, it gets to the partition editor start up and hangs.
   the secondary terminal doesn't have a status bar

*) the tied_keyboard setting is read during getDefaults() in UiCrtFrame
   but tied_keyboard doesn't make sense for term mux because it is not
   an independent address

*) print preview crashes now.  I'm not sure when it started happening.
   study F:\Jim\libs\wx-3.1.0\samples\printing
   trying to print fails too.
   build a sample app which uses print dialog and see if it works there.

*) 2236DE_TerminalUserManual.700-5711B.6-81.pdf, page 15 says all keys
   repeat except RESET, EDIT, and underline.  what implication does that
   have for the emulator?

*) huh, my CRT actually is a 2336. no wonder I was confused with 2236/2336.

*) MXD mode, VP OS 2.4 and EDIT/RECALL works as expected -- EDIT causes
   a leading "*".
   But MVP OS 3.5, EDIT doesn't show the "*", though recall does recall.
   Is that an OS thing or a bug in the emulator?
   MVP OS 2.6.2 is the same as 3.5.

*) add terminal mux emulation and terminal emulation so I can run MVP OS's
   - currently the division is
        + IoCardKeyboard
        + IoCardDisplay
        + UiCrtFrame
            + UiCrtStatusBar
            + UiCrtConfigDlg
            + UiCrt + UiCrt_Charset.h + UiCrt_Keyboard (all part of Crt class)
                + UiCrtErrorDlg
     Crt state is saved in the .ini file by ui/CRT-nn, where nn is the addr;
        this needs to be generalized
     The CrtFrame displays disk icons and activity, but in mux mode,
        there really shouldn't be a 1:1 mapping.  However, in the typical
        use case of one term, it is most useful.
     The CrtFrame logic enables some config options only on the "primary" crt,
        which historically has been the one at io_addr=05.  Rethink this.
        For example, I think the status line is gone on non-primary CRTs,
        which means A/A checkbox is not visible.
     Config dialog needs to allow term mux configurations.

*) add support for MVP and VLSI type CPUs
   - VP configuration should have 32KB control mem and defeature the 30ms timer
     Perhaps pop up a warning that the CPU is attempting to run an MVP OS
     if it detects a 30ms trigger.
   - MVP adds 64KB ctl mem, 30ms timer, and up to 512KB of data RAM via SL reg
        section 8 of 2200MVP_MaintenanceManual.729-0584-A.1-84.pdf lists
        what is involved to upgrade a VP to an MVP.  part of it requires
        changing the boot ROM ucode to deal with the larger program memory.
        do I have these boot ROMs?
           double check boards/other boards/6789 and see if those ROMs match
           what the emulator uses
        the MVP service manual section 8.2 (page 8-2) says
            2200 VP/MVP Bootstrap Release 2.2 has been incorporated by ECN
            #9772.  For a system to operate with an expanded memory, this ECN
            must be performed.  The old PROMS on the 210-6789 must be replaced
            with the following:
                378-2045R1 = L27
                378-2046R1 = L28
                378-2047R1 = L29
        the 6789 board that I got the 2nd set of bootstrap PROMs from
        are windowed eproms without official Wang revision numbers.
        handwritten on the chips are the following:
            L29 says "2047"
            L28 says "2046R5"
            L27 says "2045R5"
        It is possible that the contents were R5, but the EPROMs were
        later erased and overwritten, making the handwritten note
        meaningless.
   - VLSI-2 puts an 8b register at output port 80 called BSR (bank select reg);
     bit [7] of that register indicates if extended addressing should use the
     SL register of if [6:0] provided 7b of extended addressing. See MVP source
     code file BPMVP00.

*) Add 64K words of control memory, so BASIC-3/COBOL can run
   OptionC.pdf in the jim/wang2200/docs/system/2200MVP_MaintenanceManual
   directory describes the upgrade to give 64KB of control ram and
   512KB of RAM.  0x8000 to 0x8FFF is a hole where the bootstram PROM lives.
   Don't make it configurable (to reduce UI clutter).
   Just tie it to the configuration: VP gets 32K, MVP/VLSI get 64K.

*) Have an easy config mode and an expert mode.
   The config dialog would have two tabs.  The "simple" tab would have
   these configuration options:
      a) 2200T    w/ 32KB RAM, printer, two disk drives, KB + 64x16 screen
      b) 2200VP   w/ 64KB RAM, printer, two disk drives, KB + 80x24 screen
      c) 2200MVP  w/512KB RAM, printer, two disk drives, 2236 MXD, one term
      d) 2200VLSI w/  4MB RAM, printer, two disk drives, 2236 MXD, one term
   Expert mode would have the existing configuration dialog.
   - things are getting more confusing with the increased options.
     have a feature where hovering over the config button in the
     "Not OK" state will pop up an explanation of the problem

*) on toolbar, add superscript to some SF keys in (M)VP mode:
     SF4: END
     SF5: down arrow  (useful when the edited line wraps)
     SF6: up arrow    (useful when the edited line wraps)
     SF7: BEGIN

   Document in the keyboard help file there are some new keys
     Shift-Alt-R is hard reset  (changed)
     Shift-Alt-W is warm reset  (changed)
     Up arrow is S.F. 06 (up a screen line)
     Down arrow is S.F. 05 (down a screen line)
     Ctrl-Left arrow is S.F. 07 (start of line)
     Ctrl-Right arrow is S.F. 04 (end of line)

*) I'm seeing new strobes to the disk controller in MVP OS.
   IoCardDisk::CBS() handler has comments saying OB8 and OB1
   were used for various things.

*) notes on disk protocol and unimplemented commands:
    C:/Users/Jim/Documents/wang2200/disk_protocol/notes.txt

*) in a few places, term_num is hardwired to 1.
   don't worry about generalizing to N terminals until one term is working.
   in fact, maybe keep it to one terminal just to keep the user interface
   reasonable.  still, parameterize the code better even if this release
   don't take advantage of it.

*) review coding convention
    - after studying the following coding guidelines, modify/extend what is
      written in code.txt for my own future reference, and for any potential
      contributor.  then review all the code for conformance.
      review some c++ style guides and pick a convention.
                  Google: https://google.github.io/styleguide/cppguide.html
       Sutter/Stroustrup: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
    - review my naming convention. I haven't been consistent.
      eg, some_are_like_this, someAreCamelCase.
      eg, filenames UiCrt_Keyboard.cpp vs UiCrtRender.cpp
    - do this or not?
        vimgrep '!= nullptr' *.cpp
        then replace with simple boolean tests, eg
            assert(inst != nullptr);
        becomes
            assert(inst);
    - look for old-style static casts and replace with modern
        (int)foo --> static_cast<int>(foo)
    - I have code like this in multiple places:
          IoCardDisk *tthis = static_cast<IoCardDisk*>
                                      (System2200().getInstFromSlot(slot));
      but should it be reinterpret_cast<>()?

*) do a memory leak check once in a while

    - installed Dr. Memory, seems easy to use, no source changes and does
      much more than just detecting leaks.  http://www.drmemory.org/

*) Thought for possibly easier code.

    TimerCreate() returns a std::shared_ptr<Timer>.  It is up to the
    caller of TimerCreate() to remember to "tmr->Kill()" before resetting
    the pointer to nullptr, say at reset or cleanup.  The pointer can just
    be set to nullptr inside the callback routine because the scheduler has
    already removed the pointer on its side.

    What if the caller owned the pointer, and the scheduler had a weak_ptr
    to it?  When the tmr handle is reset to nullptr, or if the card is
    destroyed and its destructor kills off all non-nullptr shared_ptr objects,
    the Timer::~Timer destructor inside scheduler will automatically be
    notified.  At that point the scheduler can clean up the dead entry.
    There is no need for Kill() either -- the consumer just sets the pointer
    to nullptr and all the magic happens.

*) None of the recent changes has been compiled on OSX, so most likely there
   will be problems.  Once the code is somewhat stable under windows,
   build it on OSX and iron out the problems.

*) In MXD mode, TAB means TAB (2236DW) or FN (2236DE) (instead of STMT).
   The help page should be updated to indicate this.

*) improved 2236 terminal emulation

    - test some corner case on the real terminal
      what happens if there is an incorrect escape sequence:
      at what point are the bytes swallowed, or are they passed through?

    - 742-0903.MNL.IntegratedTerminal2236DW.85-02-27.pdf, pdf page 68 says
          2236DW and 2236DW have mostly the same character generators,
          except for characters 5F/7F/80/8D/8F/DF/FF

    - the weird thing where inverse mode causes video to be lit
      either when the current dot is 0 or the previous dot was 0
      gets tricky in the presence of box line graphics.
        1) vert is kind of screwed because it could interact with the
           glyph bitmap under it
        2) horizontal box lines should be stippled if normal video,
           but solid black if inverse mode
      the fix is either to buy into full-screen at once blurring,
      or to double the fontmap to have with/without vertical bar
    - dot stream is gated by pixclk.  not easily do-able in 2:1 dot mode
    - get rid of 1x1 dot matrix mode -- doesn't model the real hw,
      isn't readable.
    - write an opengl shader which uses the attr/char maps as a texture
      to generate the output in parallel. can also add contrast, brightness,
      blur, TV warp, etc
          Js amiga emulator using webgl for display:
              http://scriptedamigaemulator.net
          Stack overflow: using webgl to map palettized display to rgb display
              http://stackoverflow.com/questions/19695658/emulating-palette-based-graphics-in-webgl-v-s-canvas-2d
          apple II js w/webgl rendering option:
              http://porkrind.org/a2/
      in many ways this is simpler, in that it only has to deal with one
      single 10x22 dot format and can then stretch to the current screen size,
      instead of having 1:1, 1:2, 2:4 dot matrix modes.

    - pre-blurring the char set to a glyph map, then blitting to the display
      works OK, except the cursor isn't blurred because it is dynamic, and
      edges of block graphic characters are noticeable because the blurring
      kernel needs to span across characters.  it also interacts poorly
      with the box line graphics overlay.

      render unblurred and then use OGL to do the blurring.  this has the
      benefit of offering flexible scaling at low cost, and perhaps other
      video generation defect emulation.

    - allow running terminal as a separate process
        - running in process is easier to manage for the casual user, though
        - actual serial port connection
        - running via sockets, allowing local or remote connection
        - perhaps as a javascript app, with multiple terminals as tabs?

*) 10 PRINT HEX(07);:GOTO 10
   RUN
   doesn't make any sound and kind of hangs. CTRL-C eventually stops it,
   but it takes a while.  Doing PRINT HEX(0707070707070707070707) sounds
   the same as PRINT HEX(07).  Is there something in the hardware which
   ensures a given HEX(07) takes at least a certain amount of time?

   Try sending a constant stream of 07's to the real 2236. what happens?

   Each HEX(07) (re)triggers a one-shot which gates a 1KHz 555 oscillator.
   Change the logic to match by making the wav file play in a loop
   continuously until stopped, and using a timer event to schedule when
   to turn it off.  if another hex(07) arrives, cancel the timer and
   reschedule it for the new longer duration.  (see UiCrt.cpp)

   This means that the wav creation logic should not be as large as it
   is, and instead it should be exactly one cycle with perfect begin/end
   phase matching (no overlap).

   7011.pdf shows that hex(07) causes a low to a 9602 retriggerable one-shot.
   pin 11: active low trigger
   pins 14/15: 10uF electrolytic
   pin 14: 18K pullup
   pulse width is 0.31*R*C ns, R in kohms, C in pF
               == 0.3*18*10M = 97ms

   that pulse lifts the reset pin of a 555.  The 555 is configured with
      pin 7 pulled up to 5v by 1K
      pin 6,8 with 0.1uF tantalum to ground
      an 8.2K (maybe 6.2K) between pins 7 and 6/8
   an online calculator says this should be 830Hz if R2 is 8.2K,
                                         or 928Hz if R2 is 6.2K
   A different calculator computed 1072 Hz for 6.2K.

   The 7159 schematic (page 1, in the middle, at the bottom) is clearer.
   The 9602 R=18K,C=18uF.  The 555 R1=1K, R2=8.2K, C=0.1uF.
   That changes the timing a bit.

   https://wang2200.org/docs/system/2200_SystemsMaintenanceManual.03-0025-0.1975.pdf
   page 6-11 (pdf page 207) describes how long the bell lasts for the original
   CRT controller, but it isn't clear without the corresponding schematic
   exactly what it means.

*) add disk unit addressing cheatsheet?  I have forgotten the ins and outs.
    3xx
    Bxx
    Dxx
    F vs R vs T

    page 12-18 of MultiuserBasic2RefManual.700-4080F.3-91.pdf says this:
      platter specification: T indicates that the disk address itself specifies
      which disk in the disk unit is to be used.  T must be used whenever device
      type Dxx is used to access a disk.  In most statements, platter
      specifications F and R are supported for compatibility with older
      versions of BASIC-2 and Wang BASIC when using device type 3xx or Bxx.

    page 1-2 etc of WangBasic2DiskRefManual.700-3081G.6-81.pdf has a table

        MODEL      PLATTER       DEVICE ADDRESS
        ---------  -----------   ---------------
        2280-1     Removable     D10 (or B10)*
                   Fixed         D11 (or 310)

        2280-2     Removable     D10 (or B10)
                   First Fixed   D11 (or 310)
                   Second Fixed  D12
                   Third  Fixed  D13

        2280-3     Removable     D10 (or B10)
                   First Fixed   D11 (or 310)
                   Second Fixed  D12
                   Third  Fixed  D13
                   Fourth Fixed  D14
                   Fifth  Fixed  D15

    page 1-5 of the same manual says

        The slave drive in a Model 2260C-2, 2260BC-2 or 2280 dual drive system
        is treated much the same as the third drive in the Model 2270-3.
        Although it is functionally an extention of the Master drive, it is
        assigned a separate address which is always HEX(40) greater than the
        address of the Master disk.  If the Master drive's default address is
        310, the address of the Slave drive would be 350; if the address of the
        Master drive is 320, the address of the Slave drive is 360, etc.
        As an example, for the 2260C-2 or 2260BC-2, statement 10 below accesses
        the fixed platter in the Slave drive assuming that the primary address
        in the Master drive is the default address, 310.
            10 SAVE F/350, "FILE4"
        The statement 10 below accesses the first platter of the Slave drive in
        a 2280 dual drive system.
            10 SAVE T/D51, "FILE6"

    via experimenting of LIST DCT/blah

        LIST DCT/310  ==  LIST DCF/310
        LIST DCT/B10  ==  LIST DCR/310
        LIST DCT/320  ==  LIST DCF/320
        LIST DCT/B20  ==  LIST DCR/320

        LIST DCT/D10  ==  LIST DCR/310
        LIST DCT/D11  ==  LIST DCF/310
        LIST DCT/D20  ==  LIST DCR/320
        LIST DCT/D21  ==  LIST DCF/320  ? hmm crashes emulator

*) Document how to work around this problem in the README.

   the printer config allows picking either LPT1 or LPT2 as the real printer
   to stream to.  This doesn't work if the computer has a USB printer.
   using "net use LPT1: \\JIM-860\HP-920 /PERSISTENT:YES" does map LPT1 to the
   named network printer, but at least in my case, the printer doesn't model a
   simple ASCII printer.  It apparently is expecting some HP protocol or
   something.

   This guy wrote a lib to allow querying which printers are available,
   and returning properties about a given printer.
      http://hdrlab.org.nz/projects/wxwidgets-projects/custom-print-dialog-toolkit/
   It doesn't address the above point, it seems.

    + Go to "Devices and Printers" control panel.
    + select the "Add a printer" menu at the top.
    + specify "Add a local printer"
    + under "Use an existing port:", select the one corresponding to your USB printer
      ("USB001" in my case); press "Next"
    + it now asks to install the printer driver.  Under Manufacturer, pick "Generic".
      Under Printers, pick "Generic / Text Only"; press "Next"
    + select "use the driver that is currently installed" (at least, that is what I did);
      press "Next"
    + time to create a printer name.  I made mine "USB-ASCII"; press "Next"
    + from a dos prompt, type
        NET USE LPT2: \\<machine_name>\USB-ASCII /PERSISTENT:YES
      it should reply "The command completed successfully"
    + from the Wang 2200 emulator printer windows, select LPT2 as the real printer to
      direct output to
    + in my case, I had to do "SELECT LIST 015" to get the wang to put out a
      line feed after each carriage return.  The 215 device just ends each line
      with a CR and no LF.
    + if the program ends without filling the last page, you may need to send a
      HEX(0C) (page feed) to the printer to flush out the partial page.

*) When changing configurations, currently I:
        - destroy current config
        - rebuild world
   Would it be cleaner to do the following?
        - build new world
        - on success, swap to new world, then destroy old world
        - on failure, report problem, and old world is still usable

*) update the website (and build notes) with directions on how to make
   the thing such that it doesn't have DLL dependencies.  What a mess.
      1) declare "_BIND_TO_CURRENT_CRT_VERSION=1" in the wx libs that
         the applications uses, for the release versions of adv, base, core
      2) declare "_BIND_TO_CURRENT_CRT_VERSION=1" in the wangemu properties
      3) copy Microsoft.VC.CRT from
            /Program Files/Microsoft Visual Studio 9.0/VC/redist/x86
         to the top level emulator directory
   see
    http://www.microsoft.com/communities/newsgroups/en-us/default.aspx?dg=microsoft.public.vstudio.general&tid=2d0b8055-3fe2-482b-9fb2-731eb51859ee&cat=&lang=en&cr=US&sloc=&p=1

*) finally got a wang PC keyboard.  there are some extra keys, but the guess
   I made how they'd be expressed was wrong (see UiCrt_Keyboard.cpp).
   This is what the wx sample app "keyboard" sees:

                  no shift   shift    control   alt
    F11:          F11        S-F11    C-F11     A-F11
    F13:          ALT-F3     C-S-F3   C-A-F3    A-F3
    F14:          ALT-F4     C-S-F4   C-A-F4    A-F4
    F15:          ALT-F5     C-S-F5   C-A-F5    A-F5
    F16:          ALT-F6     C-S-F6   C-A-F6    A-F6
    CANCEL:       ALT-F7     C-S-F7   C-A-F7    A-F7
    HELP:         ALT-F8     C-S-F8   C-A-F8    A-F8
    GL:           ALT-F9     C-S-F9   C-A-F9    A-F9
    Erase/DecTab: ALT-F10    C-S-F10  C-A-F10   A-F10
    EXEC/END:     END        S-END    C-END     A-END

    maybe tie it in with the next bullet item.

*) make keyboard mapping configurable
    - requested by Mark Musen, who runs it on a mac under virtual PC.
      there is no pause/break (->HALT/STEP) key on that setup.
      (but ctrl-c should work for this specific case, right?)

*) allow pasting text to the emulator from the clipboard.  should be easy.
   copying text from the screen is significantly more work, as I'd have
   to track start & end selection, account for scrolling, have some visual
   indication.

*) emulate "CPU running" light on keyboard (first-gen only)
   double check -- it is probably (cpu waiting for input && 01 selected)

*) add a debugger/monitor
    - the VP disassembler doesn't match the assembler syntax as specified
      in the 2600 sw development manual.
      (2200MVP_ComputerArchitecture.11-79.pdf, pdf page 81 or so)

*) emulate plotter?  no point really without an interesting program.
   plotter commands:
        80 | p = start of plot command

        80 | t = step +x,+y
        80 | r = step +x,-y
        80 | s = step -x,+y
        80 | q = step -x,-y

        80 | v = step  0,-y
        80 | w = step  0,+y

        80 | x = step -x,0
        80 | y = step +x,0

        80 | z = move to zero position (user defined manually)
        80 | u = end of plot command

   The BASIC-2 manual mentions SELECT PLOT and says that the C driver
   type sends plotter commands in binary, speeding things up.  The manual
   doesn't describe PLOT!  But the 2200 type PLOT commands work.  I wonder
   if they have been augmented.  It would be nice to have a Plotter manual.

   the 2232 was a flatbed plotter.  in the docs/schematics/peripherals dir
   is 6337 -- which is the "pen control & command decoder" for this plotter.

*) allow term MUX to connect to a real serial port
        - a mac/linux/win lib: http://sigrok.org/wiki/Libserialport
        - http://wjwwood.io/serial/
        - https://iftools.com/opensource/ctb.en.php
        - windows+linux only: http://www.teuniz.net/RS-232/

*) emulate cassette tape?
   some information about it:
      http://www.wang2200.org/docs/internal/2200_TapeDriveSpecifications.2-73.pdf
      http://www.wang2200.org/docs/internal/2200_IO_Specifications.6-72.pdf
   see also
      c:\users\jim\documents\wang2200\io-notes.txt
   It might be intellectually satisfying to dig into the details, but cassette
   operation was a drag back then and it would never get used now.

*) this is kind of obscure, but the #ID function returns a "unique" ID per
   system.  it comes from locations 8004 and 8005 of the boot PROM
   (so says BPMVP0E). The boot prom of my emulator happens to return 4136.
   Make it a config option?

*) useful resources for MXD emulation:
   (save for later after I forget this stuff)
   MXD 8080 code partial disassembly:
        C:/Users/Jim/Documents/wang2200/boards/LVP\ box/7291_dasm/asm/mxd.asm
   MVP mxd-related microcode, especially
        C:/Users/Jim/Documents/wang2200/disk_images/unreleased/kryoflux/MVP_3.5_Source_Aug_91/mvp_3.5_source_code/JLMVP32A
   MXC,D,E notes:
        C:/users/jim/documents/wang2200/boards/terminal_mux_notes.txt
   https://wang2200.org/docs/system/2200MVP_MaintenanceManual.729-0584-A.1-84.pdf
       section F has schematics for many MVP cards, including MXD (7290-1, 7291-1)
       (pdf page 336, ...)

*) check out these tips on using wxWidgets under visual studio:
    http://www.litwindow.com/Knowhow/wxHowto/wxhowto.html

============================================================================
release checklist (roughly in this order)
============================================================================

- review FIXME and TODO comments
- review that the code complies with the self-imposed style guide
- run dr_memory to find memory leaks
- remove any cruft files
- review and update the files to be included with the emulator, including
    - html files
    - relnotes.txt
    - build.txt
    - code.txt
    - README.md
    - todo.txt
    - disks/...
    - scripts/...
    - wvdutil/...
- package for windows
- package for mac
- unpackage on clean windows & mac machines and very emu works
- update the website
- archive a snapshot
- to prevent confusion, immediately update the UiMyAboutDlg.cpp
  and relnotes.txt files to the next pre-whatever revision number

============================================================================
other tasks
============================================================================

*) recover tapes
    - wang backup tapes are probably QIC-02
        http://www.lintech.org/comp-per/11MAGTAP.pdf
        http://www.qic.org/html/qicstan.html#02
      but wang had a wang-proprietary format mode
      DataStorageCabinetMaintenanceManual.741-1806.9-87.pdf, page 10-2, says
        storage capacity of 45 MB with 45-ft tape, which is compatible with
        the idea that a 600' tape would store up to 600 MB.
        the parts list, page 12-4, says the drive is 725-1481, vendor MT-2ST
        page 12-5 has hand written notes
            high density tape (45 60M)  725-1482-1/725-4055-1
            150M xtra density tape      725-7548 (teac mdl# CT600-N)
            teac 150M PROM (on drive w/wang id) 730-1774
      DS_DataStorageCabinetUsersManual.715-0740.5-87.pdf
        chapters 6 & 7 are useful
        chapter 7 has GIO sequences for each tape operation command
            decode them and see if they use wang proprietary format or not
            or perhaps these are communicating to the tape controller,
            and the tape controller them maps these to teac-native SCSI
            commands, in which case maybe I can't tell.  (almost certainly
            the GIO$ commands are being interpreted by a uprocessor in the
            controller, and aren't the low level commands sent to the tape
            drive itself).
        A-2 specifications:
            8000 bpi, 90 ips, 9 physical tracks
            elsehwere: 8 tracks for data, 9th track for directory
            data is written in 512 byte blocks.  there is a 128 block buffer
            where write data is accumulated then written all together either
            when the buffer gets full or a WRITE FILE MARK command is issued.
        p 7-3 (60): To write data to the tape, the tape must first be
            positioned beyond the current end of data.  ...
            ... Note: Data cam be a[[emded pmtp a ta[e. bit data cannot be
                successfully overwritten without first erasing the entire tape.
      jan van de veen has two DS cabinets
      http://mcbx.netne.net/computers/media/teac/index.htm says:
        This unit is communicating with a proprietary interface similar to
        SCSI, but incompatible with SCSI and requires a special interface
        card.
        This page also has a couple interesting links.
        There are some MT-2ST drives which are SCSI, some where are SCSI SE,
        some which are QIC-02.  Perhaps his statement is true for the model
        which he has.
    - adaptec AHA-2930LP scsi interface cards apparently work with win/7
        and are $15 on ebay.  many are for macs, but even the ones for
        windows probably can't talk to the wang because it isn't native scsi.

============================================================================
--- wvdutil issues ---
============================================================================

*) crashes the program
   wvdutil.py bahia/older_2275/2275_D12.wvd
   list DTEST

*) see 1990 document describing program disk formats:
     https://wang2200.org/docs/internal/CS-2200-386_DiskCatalogAndFileStructure.pdf
   it describes how MVP vs MVP wrap mode works, as well as 386 "new" mode.
   the bahia/older_2275/2275_D11.wvd disk has some examples, eg
      BOOTREC (386, non-wrap)
      WRAP (mvp wrap mode) vs WRAP2 (386 new mode, wrap)
      UNWRAP (386 new)

*) pyinstaller results in a very slow to start program.  investigate
   using nuitka.net to speed it up.

*) identify (and list?) printer control files. from wvdutil.py comments:
        MVP OS 2.6 and later have files with names like "@PM010V1" which
        are printer control files.  they all start with 0x6911.
        add logic to allow check, scan, and perhaps list them.
        Basic2Release_2.6_SoftwareBullitin.715-0097A.5-85.pdf
        has some description of the generalized printer driver.

*) identify (and list?) microcode.
   does WvdHandler need a different hook to advertise file formats which can
   be recognized but not listed?  or does the lister defer to a generic dump
   format or data format as the case may be?

*) the compare command in wvdutil.pl doesn't allow compare two files with
   different names.  it would be useful to allow it.

*) wvdutil.py guessFiles()

    - is a hacked up version of the old FSM.  see the big comment block there.
      try rewriting it to use the checkBlocks functions and see if that works
      without being too slow.
      note: the checkers will probably need to receive a new option val,
            maybe "speculative".  They should stop when they detect an error,
            but not return an error, and instead just return the number of
            sectors which were valid before seeing the error.
            q: in this speculative mode, do data and program need to be well-
               formed, or allow fragmentary programs and data files?

*) dir currently shows program, data, edit file type.  programs also show
   protected or scrambled. consider adding a mechanism to indicate if the
   program is specifically BASIC-2 or Wang BASIC (if it is compatible with
   both don't say anything special).

   - stuff.wvd: MSTRMIND has a few lines which are preceded by a space.
     Wang BASIC reads it fine; BASIC-2 (as of vp-2.4) silently drops the
     sector entirely.

   - check if any BASIC-2 specific tokens are used. other checks we could
     make might require real parsing.

     "$" command prefix is 0xEA, so maybe do a simple grep search for 0xEA
     followed by BASIC-2 specific commands.
      BASIC-2 only that can't be detected just by token:
          IF A>0 THEN PRINT A  (THEN token followed by something other than space or line number token)
          HEXUNPACK         ('HEX' token then 'UNPACK' token)
          NEXT I,J          heuristic: "," after NEXT and before ":"
          ADDC(A$,B$) --> A$ = ADDC B$ or A$ = A$ ADDC B$  (same token, xEA 'ADD', used in both situations)
                             heuristic: ADD/BOOL/etc token after "=" and before ":"
          PRINTUSING TO ...
          ON <expr> SELECT ...
          SELECT @PART      (SELECT is a token, @PART are individual ascii letters)
          SELECT ERROR
          BOX(              (individual letters)
          $PACK             ($(xEA) and PACK are tokens)
          $UNPACK           ($(xEA) and UNPACK are tokens)
          $OPEN             ($(xEA) and OPEN are tokens)
          $CLOSE            ($(xEA) and CLOSE are tokens)
          $FORMAT           ($(xEA) then individual letters)
          $BREAK            ($(xEA) then individual letters)
          $MSG              ($(xEA) then individual letters)
          $PSTAT            ($(xEA) then individual letters)
          $RELEASE PART     ($(xEA) then individual letters)
          $RELEASE TERMINAL ($(xEA) then individual letters)
          $ALERT
          SPACE
          SPACEK
          TIME
          ERR function
          ERR$ function
          PRINT HEXOF(...)
          HEXPACK
          HEXUNPACK
          #ID

      BASIC-2 only that can't be detected just by token, but parsing is tougher
          VAL(A$,2) or worse, VAL(STR(A$,<expr>,<expr>),<expr>)
          @A, @$A, etc global vars

      Maybe have a function to strip out REM, and remove everything between
      quotes, and squish out extra spaces.  Then do the pattern matching for
      $BREAK and such.  If so, maybe these checks could be incorporated into
      the listBlock logic, and simply drop the resulting list.

   - Related to the previous point, the following might be a useful heuristic
     to know whether a program was written in Wang BASIC or BASIC-2.

     Entering "10 PRINT A/3" in Wang BASIC, the space between the line number
     and PRINT is saved in the file.  "10PRINT A/3" will show up just like
     that.  But on BASIC-2, there is always a space printed after a line
     number, even if one wasn't entered.  If one is entered, but only the first
     one, it is removed before tokenizing the rest of the line.

============================================================================
Misc
============================================================================

*) Microcode assembler notes

   For each source file FOO, the assembler creates two symbol files:
        FOO$ = local symbols from FOO
        FOO& = external symbols from FOO

   These output file seems to be much like a source file, except the first
   sector starts
       81 01 fc <124 bytes, space padded> fd <128 dontcare bytes>
   The subsequent sectors are like edit: four 62 byte strings, but with their
   contents packed. The sector always ends ff fd 00.

    The FOO$ stream contains a sequence of
       <A       > 00 0a 03 11 db   line 180 = 00B4. 0311db=201179 = module 2, file 01, line 179
       <ABS     > 00 c0 03 11 e4   line 189 = 00BD
       <C       > 00 0c 03 11 dd   line 182 = 00B6
       <CA      > 00 01 03 11 fe   line 215 = 00D7
       <CBS     > 00 10 03 11 e6   line 191 = 00BF
       <D       > 00 0d 03 11 de   line 183 = 00B7
    Those trailing five bytes are pondered on elsewhere, but I can't find it now.
    That speculation and the following should be consolidated to reduce confusion.
    However, I have cracked the meaning by studying the assembler code.
    Each entry is 13 bytes, packed with
        byte 1-8:   S1$(K) -> symbol name, 8 letters
        byte 9-10:  S3$(K) -> value, 16b
        byte 11-13: S4$(K) -> def. location, 24b (MMMFFLLL in base 10)
     MMMFFLLL, MMM=module, FF=file of module, LLL=line of file

    2600ASMS
        line 1000, has a description of the variables used.
    2600ASM2
        line 2050: FOO$ file is written (local symbol table)
        line 2080: FOO& file is written (external symbol table)
        line 7340: three byte U1$ value is generated: I1=F*100000+F2*1000+L
        line 1100: "NEW FILE ENTRY POINT" and F2 is incremented each time
                   (each CONT I assume)

    The FOO& stream is also packed like an EDIT file, but the stream has 10-byte
    entries:
        <8 char name> <msb> <lsb>
    There is no source location as in FOO$.  It seems that it lists the symbols
    that FOO referenced which were not defined locally.

    Looking at 2600_BASBOL_DevelopmentTools.3-81.pdf, a few notes:
    2600 Assembler manual, Jan 31, 1978
        EDITOR is for 2200C/T and was written by Dave Angel
        EDIT26 is for 2200VP and was written by Dave Angel
    And of course EDIT/EDIT.{2,3,4,5} was an even later rewrite.
    Line 8400 of d14.2600ASM2 indicates there are two EDIT file formats in use.
    The old format starts with "*FILE"; the new format starts with HEX(0201).

    https://wang2200.org/docs/system/2200MVP_ComputerArchitecture.11-79.pdf, p 73
          "2600ASMS" contains the start-up program
          "2600ASM2" contains the assembler program
          "2600ASMB" contains the block allocating program
          "2600ASMG" contains the data file generating program
          "2600ASMD" contains the data file produced by "2600ASMG"
          "SCROSS" contains the master cross reference program
          "READTB" contains the 9-track tape to printer program.
          (followed by directions on how to use the programs)

*) holy crap, read the message from Richard L Lockley, 8/20/2003 in the
   wang folder.  I never replied, until just now (10/8/08).  He claimed
   to have every wang document up to 1985.  Maybe he has 3300 docs.
    As of 2/2013:
        (314) 921-4109 (home #)
        7314 Elm Grove Ct
        Hazelwood, MO 63042-2008

*) notes about why MAT PRINT causes a hang on the 2200B ROMs.
   it turns out that the real hardware does too, according to Georg.

       6310.pdf (ALU): conn3, pin 10 has !ERG.  This goes to
            When is ERG active?
            It is a function of A[3:1], B[3:1], R[19:0]
            ERG = ((A==11xx) || (A==x11x) || (B==11xx) || (B==1x1x)) & "D0"
            D0 = R16 & !(!DSC &&  (!R17 ||  R19))
               = R16 &  (!DSC || !(!R17 ||  R19))
               = R16 &  (!DSC ||  ( R17 && !R19))
                 (I think D0=1 means decimal mode)
            So it seems that if one does a BCD op with operands that are
            out of range, it would have set ST3-1.  The schematic is wrong,
            either that or this is really weird, since the second A term
            fires on 6, 7, 14, 15 and lets 10 and 11 pass.  The B term seems
            correct.
       6311.pdf (I/O), conn3, pin 9.
            When ERG is active (low), it sets bit D2 (0010) of the ST3 latch,
            however the schematic shows this flop as not driving anything,
            and the mux that would have logically accepted ST3-1 instead
            is fed from L24A/!QD, which is latching !IB5 -- which is used
            to sense 80 char wide terminals vs 64 wide (other peripherals
            might use it too, but not that I know of).
        On the 6710 (2200T CPU), this signal is driven with a meaningless value.

        OK, so this isn't causing the mismatch.

        ====

        Dumping instructions after 10 MAT PRINT A<CR>,
            2200Tdbg.txt vs 2200Bdbg.txt
        cycle 2 of the first lines up with cycle 13 of the second.
        at cycle 40/51, 00AC is read and 05/04 is returned (why the difference?)
        instructions are in until cycle 665/676 where there is a ucode difference:
            B 01F8 / SB 006D
        Things sync up again a while later (search on corresponding /RAM.ROM),
        and stay in sync for the most part until cycle 4685/4683, which is
            MV CL,PC2 ; MV CH,PC1 ; MV F5,PC4; MV F4,PC3
        in the 2200T case, PC=4A0B, for 2200B, it becomes 26FD.
        Then at cycle 4698/4696, "TPI" (transfer PC to IC) causes major divergence:
            2200T goes to 4A0B (MAT handler), while
            2200B goes to 26FD:
                26FD: MVI 4,PC1
                26FE: B   7E0C  (inside patch routines)
                7E0C: B   3400
                3400: BNE 0F,0,34FF  (opcode=FFFFF; really meaningless)
                34FF: BNE 0F,0,34FF  (opcode=FFFFF; really meaningless)
        Looking at the constant rom tables, the entry for MAT is
            2200T: 4A 0B   03  4D 41 54  A8
                   handler len M  A  T   token
            2200B: 26 FD   03  4D 41 54  A8
                   handler len M  A  T   token
        So it looks like the emulator is doing exactly the right thing;
        the question is why does the constant ROM have an entry for MAT,
        or at least why does it jump to a patch routine which then jumps to
        non-existant code vs an error handler.

        A: the real hardware does the same thing.  The atom table points
           to a non-populated ROM location, and death ensues.

*) DATAMATH  CALCULATOR  MUSEUM (www.datamath.org) has a tiny accuracy
   benchmark that they run on all the calculators they come across.
   In Wang BASIC it is expressed as:

    10 SELECT D
    20 PRINT ARCSIN(ARCCOS(ARCTAN(TAN(COS(SIN(9))))))

   Here are the results:
    Wang 2200T:  9.00000222872
    Wang 2200VP: 9.000000590471

*) this doesn't have to go onto the web site, but since I collected the
   data, I don't want to just delete it.

   After running some experiments, it would appear that the CS/386 interpreter
   is a different implementation altogether, not a microcode binary translator.
      + PRINT ARCSIN(ARCCOS(ARCTAN(TAN(COS(SIN(9))))))
          VP BASIC 2.3:
              9.000000590471
          MULTI-USER BASIC-2 3.5:
              9.000000590471
          MULTI-USER BASIC-2/386 1.3.00:
              9.000000586479
      + PRINT RND(0), RND(1)
          VP BASIC 2.3:
              .1584625767084  .361319611557
          MULTI-USER BASIC-2 3.5:
              .1584625767084  .361319611557
          MULTI-USER BASIC-2/386 1.3.00:
              .1584625767084  .5930297180313
      + Enter
            10 DATA 1,2,3,    4,5,6
        On the VP-based CPUs, the extra spaces are preserved;
        on the CS/386, the extra spaces are lost.

*) experiments:
    save a multi-sector program to disk.  make these unexpected file images on
    disk.  try loading in Wang BASIC and BASIC-2 to see if they are accepted.

    NOMID:  8DAMEN, with the wrong name
        10 DIM A$(16)16
        20 DATA LOAD BA R(171) A$()
        30 STR(A$(1),2,8)="BADNAME "
        40 DATA SAVE BA R(171) A$()
    Result: DIR shows the name in the catalog, not the file header (as expected)

    NOHEAD: 8DAMEN, with the header block removed (other sectors moved back)
        10 DIM A$(16)16
        20 DATA LOAD BA R(164) A$()
        30 DATA SAVE BA R(163) A$()
        40 DATA LOAD BA R(165) A$()
        50 DATA SAVE BA R(164) A$()
        CLEAR
        LOAD R"NOHEAD"
    Result: ERR D88 (Wrong Record Type)

    RATTE2: RATTE, but with the control record with the wrong info
        real one: "20 00 0c ..."
        10 DIM A$(16)16
        20 DATA LOAD BA R(186) A$()
        30 STR(A$(1),3,1) = HEX(03)
        40 DATA SAVE BA R(186) A$()
    Result:
        LIST DCR shows only 3 records used, 9 free
        LOAD R"RATTE2" loads the whole program fine

        10 DIM A$(16)16
        20 DATA LOAD BA R(186) A$()
        30 STR(A$(1),3,1) = HEX(10)
        40 DATA SAVE BA R(186) A$()
    Result:
        LIST DCR shows only 16 records used, 65532 free
        LOAD R"RATTE2" loads the whole program fine

    SAVE R(3)"RATTE3"  (RATTE but with three spare sectors)
    Then write a program to put an empty sector in the middle.
    The "empty" sector is just "00FD...", that is, the control
    byte 00 is correct, and FD is an end of block byte.
        10 DIM A$(16)16
        20 FOR S=198 TO 194 STEP -1:REM 201 is the control sector
        30 DATA LOAD BA R(S) A$()
        40 DATA SAVE BA R(S+1) A$()
        50 NEXT S
        60 A$()=ALL(00)
        70 STR(A$(1),1,2)=HEX(00FD)
        80 DATA SAVE BA R(194) A$()
     Sector 194 is lines 530 to 630
     Result: no problems

     SWAPPED: RATTE but with two sectors swapped
        10 DIM A$(16)16, B$(16)16
        20 DATA LOAD BA R(204) A$()  lines 80-150
        30 DATA LOAD BA R(206) B$()  lines 250-320
        40 DATA SAVE BA R(206) A$()
        50 DATA SAVE BA R(204) B$()
     BASIC is happy, but when wvdutil.py does LIST of that file,
     the lines show up out of order.

     DUP: PRIMES but with line 40 renamed to 30, which should overwrite
          the existing line 30
        10 DIM A$(16)16
        20 DATA LOAD BA R(215) A$()
        30 STR(A$(8),1,2)=HEX(0030)
        40 DATA LOAD BA R(215) A$()
     Result: line 30 disappeared, and 40 took its place

     Looking at the MVP 3.5 source code, each line is decoded from the
     input buffer.  A check is made, either "fast threading" or "slow threading".
     In the first case, a two-way link is made between the old highest line
     and the new highest line. Otherwise it has to do a slow search to see
     where the new line fits and link it in there (possibly overwriting an old
     line).  This has to be robust to allow overlays to work.

    1) change the USED value in the last sector to something too short or too long
       it shows USED as whatever was written, and FREE is correspondingly wrong,
       even perhaps wrapping negative and appearing as 65532.  But loading the
       program is just fine.
    2) rewrite the header record to have the wrong filename.
       no problem; the dir listing shows the catalog name, not the header name
    3) shift all the sectors back by one, destroying the header record
       ERR D88 (Wrong Record Type)
    4) replace one of the middle sectors with no valid lines, just an End-Of-Block.
       no problems: loaded fine
    5) create a file where the lines are not saved in ascending order
       easiest to just swap two sectors.
       Result: it dealt with it fine
    5b) modified a program containing lines 30 and 40 such that line 40 was
        renamed to line 30.  it loaded OK and the renamed 40 replaced 30.

    These will inform whether wvdutil should tolerate these errors too.
    Create a disk with a small test program, "TEST".  Then write a program
    to read each block and write out a new file, but with various errors.

*) note, not that it mattters, but "SAVE DAR (600)" which used direct address
   mode to save a program, saves a header sector with an all-blank name.
   The last sector written is the trailer block, and of course there is
   no control record after the program.

============================================================================
wxBitmap vs wxImage refresher
============================================================================
In short,

    wxBitmap is a platform-dependent image format
    wxImage  is a platform-independent image format

wxImage is just a buffer of RGB bytes with an optional buffer for the alpha
bytes. It is all generic, platform independent and image file format
independent code. It includes generic code for scaling, resizing, clipping,
and other manipulations of the image data.

OTOH, wxBitmap is intended to be a wrapper of whatever is the native image
format that is quickest/easiest to draw to a DC or to be the target of the
drawing operations performed on a wxMemoryDC.

By splitting the responsibilities between wxImage/wxBitmap like this then
it's easier to use generic code shared by all platforms and image types for
generic operations and platform specific code where performance or
compatibility is needed.

--- also

If you need direct access the bitmap data instead going through drawing to
it using wxMemoryDC you need to use the wxPixelData class (either
wxNativePixelData for RGB bitmaps or wxAlphaPixelData for bitmaps with an
additionally alpha channel).

--- also

Implemented on Windows, GTK+ and OS X:

    wxNativePixelData: Class to access to wxBitmap's internal data without
                       alpha channel (RGB).
    wxAlphaPixelData: Class to access to wxBitmap's internal data with
                      alpha channel (RGBA).

Implemented everywhere:

    wxImagePixelData: Class to access to wxImage's internal data with
                      alpha channel (RGBA).

wxMSW note: efficient access is only possible to the bits of the so called
device independent bitmaps (DIB) under MSW. To ensure that wxBitmap uses a
DIB internally and not a device dependent bitmap (DDB), you need to pass an
explicit depth to its ctor, i.e. either 24 or 32, as by default wxBitmap
creates a DDB of the screen depth.

--- final thoughts

That explains some things, but then why does it barf under MSW with an
explicit bitmap depth of 32 and using wxAlphaPixelData?

-----
vim: et ts=8 sw=4
